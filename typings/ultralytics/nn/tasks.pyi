"""
This type stub file was generated by pyright.
"""

import contextlib
import pickle
import torch

class BaseModel(torch.nn.Module):
    """The BaseModel class serves as a base class for all the models in the Ultralytics YOLO family."""
    def forward(self, x, *args, **kwargs): # -> Tuple[Tensor, ...] | Any:
        """
        Perform forward pass of the model for either training or inference.

        If x is a dict, calculates and returns the loss for training. Otherwise, returns predictions for inference.

        Args:
            x (torch.Tensor | dict): Input tensor for inference, or dict with image tensor and labels for training.
            *args (Any): Variable length argument list.
            **kwargs (Any): Arbitrary keyword arguments.

        Returns:
            (torch.Tensor): Loss if x is a dict (training), or network predictions (inference).
        """
        ...
    
    def predict(self, x, profile=..., visualize=..., augment=..., embed=...): # -> Tuple[Tensor, ...] | Any:
        """
        Perform a forward pass through the network.

        Args:
            x (torch.Tensor): The input tensor to the model.
            profile (bool):  Print the computation time of each layer if True, defaults to False.
            visualize (bool): Save the feature maps of the model if True, defaults to False.
            augment (bool): Augment image during prediction, defaults to False.
            embed (list, optional): A list of feature vectors/embeddings to return.

        Returns:
            (torch.Tensor): The last output of the model.
        """
        ...
    
    def fuse(self, verbose=...): # -> Self:
        """
        Fuse the `Conv2d()` and `BatchNorm2d()` layers of the model into a single layer, in order to improve the
        computation efficiency.

        Returns:
            (torch.nn.Module): The fused model is returned.
        """
        ...
    
    def is_fused(self, thresh=...): # -> bool:
        """
        Check if the model has less than a certain threshold of BatchNorm layers.

        Args:
            thresh (int, optional): The threshold number of BatchNorm layers. Default is 10.

        Returns:
            (bool): True if the number of BatchNorm layers in the model is less than the threshold, False otherwise.
        """
        ...
    
    def info(self, detailed=..., verbose=..., imgsz=...): # -> tuple[int, int, int, float | Any] | None:
        """
        Prints model information.

        Args:
            detailed (bool): if True, prints out detailed information about the model. Defaults to False
            verbose (bool): if True, prints out the model information. Defaults to False
            imgsz (int): the size of the image that the model will be trained on. Defaults to 640
        """
        ...
    
    def load(self, weights, verbose=...): # -> None:
        """
        Load the weights into the model.

        Args:
            weights (dict | torch.nn.Module): The pre-trained weights to be loaded.
            verbose (bool, optional): Whether to log the transfer progress. Defaults to True.
        """
        ...
    
    def loss(self, batch, preds=...):
        """
        Compute loss.

        Args:
            batch (dict): Batch to compute loss on
            preds (torch.Tensor | List[torch.Tensor]): Predictions.
        """
        ...
    
    def init_criterion(self):
        """Initialize the loss criterion for the BaseModel."""
        ...
    


class DetectionModel(BaseModel):
    """YOLO detection model."""
    def __init__(self, cfg=..., ch=..., nc=..., verbose=...) -> None:
        """Initialize the YOLO detection model with the given config and parameters."""
        ...
    
    def init_criterion(self): # -> E2EDetectLoss | v8DetectionLoss:
        """Initialize the loss criterion for the DetectionModel."""
        ...
    


class OBBModel(DetectionModel):
    """YOLO Oriented Bounding Box (OBB) model."""
    def __init__(self, cfg=..., ch=..., nc=..., verbose=...) -> None:
        """Initialize YOLO OBB model with given config and parameters."""
        ...
    
    def init_criterion(self): # -> v8OBBLoss:
        """Initialize the loss criterion for the model."""
        ...
    


class SegmentationModel(DetectionModel):
    """YOLO segmentation model."""
    def __init__(self, cfg=..., ch=..., nc=..., verbose=...) -> None:
        """Initialize YOLOv8 segmentation model with given config and parameters."""
        ...
    
    def init_criterion(self): # -> v8SegmentationLoss:
        """Initialize the loss criterion for the SegmentationModel."""
        ...
    


class PoseModel(DetectionModel):
    """YOLO pose model."""
    def __init__(self, cfg=..., ch=..., nc=..., data_kpt_shape=..., verbose=...) -> None:
        """Initialize YOLOv8 Pose model."""
        ...
    
    def init_criterion(self): # -> v8PoseLoss:
        """Initialize the loss criterion for the PoseModel."""
        ...
    


class ClassificationModel(BaseModel):
    """YOLO classification model."""
    def __init__(self, cfg=..., ch=..., nc=..., verbose=...) -> None:
        """Init ClassificationModel with YAML, channels, number of classes, verbose flag."""
        ...
    
    @staticmethod
    def reshape_outputs(model, nc): # -> None:
        """Update a TorchVision classification model to class count 'n' if required."""
        ...
    
    def init_criterion(self): # -> v8ClassificationLoss:
        """Initialize the loss criterion for the ClassificationModel."""
        ...
    


class RTDETRDetectionModel(DetectionModel):
    """
    RTDETR (Real-time DEtection and Tracking using Transformers) Detection Model class.

    This class is responsible for constructing the RTDETR architecture, defining loss functions, and facilitating both
    the training and inference processes. RTDETR is an object detection and tracking model that extends from the
    DetectionModel base class.

    Methods:
        init_criterion: Initializes the criterion used for loss calculation.
        loss: Computes and returns the loss during training.
        predict: Performs a forward pass through the network and returns the output.
    """
    def __init__(self, cfg=..., ch=..., nc=..., verbose=...) -> None:
        """
        Initialize the RTDETRDetectionModel.

        Args:
            cfg (str): Configuration file name or path.
            ch (int): Number of input channels.
            nc (int, optional): Number of classes. Defaults to None.
            verbose (bool, optional): Print additional information during initialization. Defaults to True.
        """
        ...
    
    def init_criterion(self): # -> RTDETRDetectionLoss:
        """Initialize the loss criterion for the RTDETRDetectionModel."""
        ...
    
    def loss(self, batch, preds=...): # -> tuple[int, Tensor]:
        """
        Compute the loss for the given batch of data.

        Args:
            batch (dict): Dictionary containing image and label data.
            preds (torch.Tensor, optional): Precomputed model predictions. Defaults to None.

        Returns:
            (tuple): A tuple containing the total loss and main three losses in a tensor.
        """
        ...
    
    def predict(self, x, profile=..., visualize=..., batch=..., augment=..., embed=...): # -> Tuple[Tensor, ...]:
        """
        Perform a forward pass through the model.

        Args:
            x (torch.Tensor): The input tensor.
            profile (bool, optional): If True, profile the computation time for each layer. Defaults to False.
            visualize (bool, optional): If True, save feature maps for visualization. Defaults to False.
            batch (dict, optional): Ground truth data for evaluation. Defaults to None.
            augment (bool, optional): If True, perform data augmentation during inference. Defaults to False.
            embed (list, optional): A list of feature vectors/embeddings to return.

        Returns:
            (torch.Tensor): Model's output tensor.
        """
        ...
    


class WorldModel(DetectionModel):
    """YOLOv8 World Model."""
    def __init__(self, cfg=..., ch=..., nc=..., verbose=...) -> None:
        """Initialize YOLOv8 world model with given config and parameters."""
        ...
    
    def set_classes(self, text, batch=..., cache_clip_model=...): # -> None:
        """Set classes in advance so that model could do offline-inference without clip model."""
        ...
    
    def predict(self, x, profile=..., visualize=..., txt_feats=..., augment=..., embed=...): # -> Tuple[Tensor, ...] | Any | list[Any]:
        """
        Perform a forward pass through the model.

        Args:
            x (torch.Tensor): The input tensor.
            profile (bool, optional): If True, profile the computation time for each layer. Defaults to False.
            visualize (bool, optional): If True, save feature maps for visualization. Defaults to False.
            txt_feats (torch.Tensor): The text features, use it if it's given. Defaults to None.
            augment (bool, optional): If True, perform data augmentation during inference. Defaults to False.
            embed (list, optional): A list of feature vectors/embeddings to return.

        Returns:
            (torch.Tensor): Model's output tensor.
        """
        ...
    
    def loss(self, batch, preds=...): # -> tuple[Tensor | Any, Tensor]:
        """
        Compute loss.

        Args:
            batch (dict): Batch to compute loss on.
            preds (torch.Tensor | List[torch.Tensor]): Predictions.
        """
        ...
    


class Ensemble(torch.nn.ModuleList):
    """Ensemble of models."""
    def __init__(self) -> None:
        """Initialize an ensemble of models."""
        ...
    
    def forward(self, x, augment=..., profile=..., visualize=...): # -> tuple[Tensor, None]:
        """Function generates the YOLO network's final layer."""
        ...
    


@contextlib.contextmanager
def temporary_modules(modules=..., attributes=...): # -> Generator[None, Any, None]:
    """
    Context manager for temporarily adding or modifying modules in Python's module cache (`sys.modules`).

    This function can be used to change the module paths during runtime. It's useful when refactoring code,
    where you've moved a module from one location to another, but you still want to support the old import
    paths for backwards compatibility.

    Args:
        modules (dict, optional): A dictionary mapping old module paths to new module paths.
        attributes (dict, optional): A dictionary mapping old module attributes to new module attributes.

    Example:
        ```python
        with temporary_modules({"old.module": "new.module"}, {"old.module.attribute": "new.module.attribute"}):
            import old.module  # this will now import new.module
            from old.module import attribute  # this will now import new.module.attribute
        ```

    Note:
        The changes are only in effect inside the context manager and are undone once the context manager exits.
        Be aware that directly manipulating `sys.modules` can lead to unpredictable results, especially in larger
        applications or libraries. Use this function with caution.
    """
    ...

class SafeClass:
    """A placeholder class to replace unknown classes during unpickling."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize SafeClass instance, ignoring all arguments."""
        ...
    
    def __call__(self, *args, **kwargs): # -> None:
        """Run SafeClass instance, ignoring all arguments."""
        ...
    


class SafeUnpickler(pickle.Unpickler):
    """Custom Unpickler that replaces unknown classes with SafeClass."""
    def find_class(self, module, name): # -> Any | type[SafeClass]:
        """Attempt to find a class, returning SafeClass if not among safe modules."""
        ...
    


def torch_safe_load(weight, safe_only=...): # -> tuple[dict[str, Any] | dict[Any, Any], str]:
    """
    Attempts to load a PyTorch model with the torch.load() function. If a ModuleNotFoundError is raised, it catches the
    error, logs a warning message, and attempts to install the missing module via the check_requirements() function.
    After installation, the function again attempts to load the model using torch.load().

    Args:
        weight (str): The file path of the PyTorch model.
        safe_only (bool): If True, replace unknown classes with SafeClass during loading.

    Example:
    ```python
    from ultralytics.nn.tasks import torch_safe_load

    ckpt, file = torch_safe_load("path/to/best.pt", safe_only=True)
    ```

    Returns:
        ckpt (dict): The loaded model checkpoint.
        file (str): The loaded filename
    """
    ...

def attempt_load_weights(weights, device=..., inplace=..., fuse=...): # -> Module | Ensemble:
    """Loads an ensemble of models weights=[a,b,c] or a single model weights=[a] or weights=a."""
    ...

def attempt_load_one_weight(weight, device=..., inplace=..., fuse=...): # -> tuple[Any, dict[str, Any] | dict[Any, Any]]:
    """Loads a single model weights."""
    ...

def parse_model(d, ch, verbose=...):
    """Parse a YOLO model.yaml dictionary into a PyTorch model."""
    ...

def yaml_model_load(path): # -> Any | dict[Any, Any]:
    """Load a YOLOv8 model from a YAML file."""
    ...

def guess_model_scale(model_path): # -> str | Any:
    """
    Takes a path to a YOLO model's YAML file as input and extracts the size character of the model's scale. The function
    uses regular expression matching to find the pattern of the model scale in the YAML file name, which is denoted by
    n, s, m, l, or x. The function returns the size character of the model scale as a string.

    Args:
        model_path (str | Path): The path to the YOLO model's YAML file.

    Returns:
        (str): The size character of the model's scale, which can be n, s, m, l, or x.
    """
    ...

def guess_model_task(model): # -> Any | Literal['classify', 'detect', 'segment', 'pose', 'obb'] | None:
    """
    Guess the task of a PyTorch model from its architecture or configuration.

    Args:
        model (torch.nn.Module | dict): PyTorch model or model configuration in YAML format.

    Returns:
        (str): Task of the model ('detect', 'segment', 'classify', 'pose').

    Raises:
        SyntaxError: If the task of the model could not be determined.
    """
    ...


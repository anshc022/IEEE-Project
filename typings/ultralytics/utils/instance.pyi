"""
This type stub file was generated by pyright.
"""

from typing import List

to_2tuple = ...
to_4tuple = ...
_formats = ...
__all__ = ("Bboxes", "Instances")
class Bboxes:
    """
    A class for handling bounding boxes.

    The class supports various bounding box formats like 'xyxy', 'xywh', and 'ltwh'.
    Bounding box data should be provided in numpy arrays.

    Attributes:
        bboxes (numpy.ndarray): The bounding boxes stored in a 2D numpy array.
        format (str): The format of the bounding boxes ('xyxy', 'xywh', or 'ltwh').

    Note:
        This class does not handle normalization or denormalization of bounding boxes.
    """
    def __init__(self, bboxes, format=...) -> None:
        """Initializes the Bboxes class with bounding box data in a specified format."""
        ...
    
    def convert(self, format): # -> None:
        """Converts bounding box format from one type to another."""
        ...
    
    def areas(self): # -> Tensor | NDArray[bool_] | NDArray[floating[Any]]:
        """Return box areas."""
        ...
    
    def mul(self, scale): # -> None:
        """
        Multiply bounding box coordinates by scale factor(s).

        Args:
            scale (int | tuple | list): Scale factor(s) for four coordinates.
                If int, the same scale is applied to all coordinates.
        """
        ...
    
    def add(self, offset): # -> None:
        """
        Add offset to bounding box coordinates.

        Args:
            offset (int | tuple | list): Offset(s) for four coordinates.
                If int, the same offset is applied to all coordinates.
        """
        ...
    
    def __len__(self): # -> int:
        """Return the number of boxes."""
        ...
    
    @classmethod
    def concatenate(cls, boxes_list: List[Bboxes], axis=...) -> Bboxes:
        """
        Concatenate a list of Bboxes objects into a single Bboxes object.

        Args:
            boxes_list (List[Bboxes]): A list of Bboxes objects to concatenate.
            axis (int, optional): The axis along which to concatenate the bounding boxes.
                                   Defaults to 0.

        Returns:
            Bboxes: A new Bboxes object containing the concatenated bounding boxes.

        Note:
            The input should be a list or tuple of Bboxes objects.
        """
        ...
    
    def __getitem__(self, index) -> Bboxes:
        """
        Retrieve a specific bounding box or a set of bounding boxes using indexing.

        Args:
            index (int, slice, or np.ndarray): The index, slice, or boolean array to select
                                               the desired bounding boxes.

        Returns:
            Bboxes: A new Bboxes object containing the selected bounding boxes.

        Raises:
            AssertionError: If the indexed bounding boxes do not form a 2-dimensional matrix.

        Note:
            When using boolean indexing, make sure to provide a boolean array with the same
            length as the number of bounding boxes.
        """
        ...
    


class Instances:
    """
    Container for bounding boxes, segments, and keypoints of detected objects in an image.

    Attributes:
        _bboxes (Bboxes): Internal object for handling bounding box operations.
        keypoints (ndarray): keypoints(x, y, visible) with shape [N, 17, 3]. Default is None.
        normalized (bool): Flag indicating whether the bounding box coordinates are normalized.
        segments (ndarray): Segments array with shape [N, 1000, 2] after resampling.

    Args:
        bboxes (ndarray): An array of bounding boxes with shape [N, 4].
        segments (list | ndarray, optional): A list or array of object segments. Default is None.
        keypoints (ndarray, optional): An array of keypoints with shape [N, 17, 3]. Default is None.
        bbox_format (str, optional): The format of bounding boxes ('xywh' or 'xyxy'). Default is 'xywh'.
        normalized (bool, optional): Whether the bounding box coordinates are normalized. Default is True.

    Examples:
        ```python
        # Create an Instances object
        instances = Instances(
            bboxes=np.array([[10, 10, 30, 30], [20, 20, 40, 40]]),
            segments=[np.array([[5, 5], [10, 10]]), np.array([[15, 15], [20, 20]])],
            keypoints=np.array([[[5, 5, 1], [10, 10, 1]], [[15, 15, 1], [20, 20, 1]]]),
        )
        ```

    Note:
        The bounding box format is either 'xywh' or 'xyxy', and is determined by the `bbox_format` argument.
        This class does not perform input validation, and it assumes the inputs are well-formed.
    """
    def __init__(self, bboxes, segments=..., keypoints=..., bbox_format=..., normalized=...) -> None:
        """
        Initialize the object with bounding boxes, segments, and keypoints.

        Args:
            bboxes (np.ndarray): Bounding boxes, shape [N, 4].
            segments (list | np.ndarray, optional): Segmentation masks. Defaults to None.
            keypoints (np.ndarray, optional): Keypoints, shape [N, 17, 3] and format (x, y, visible). Defaults to None.
            bbox_format (str, optional): Format of bboxes. Defaults to "xywh".
            normalized (bool, optional): Whether the coordinates are normalized. Defaults to True.
        """
        ...
    
    def convert_bbox(self, format): # -> None:
        """Convert bounding box format."""
        ...
    
    @property
    def bbox_areas(self): # -> Tensor | NDArray[bool_] | NDArray[floating[Any]]:
        """Calculate the area of bounding boxes."""
        ...
    
    def scale(self, scale_w, scale_h, bbox_only=...): # -> None:
        """Similar to denormalize func but without normalized sign."""
        ...
    
    def denormalize(self, w, h): # -> None:
        """Denormalizes boxes, segments, and keypoints from normalized coordinates."""
        ...
    
    def normalize(self, w, h): # -> None:
        """Normalize bounding boxes, segments, and keypoints to image dimensions."""
        ...
    
    def add_padding(self, padw, padh): # -> None:
        """Handle rect and mosaic situation."""
        ...
    
    def __getitem__(self, index) -> Instances:
        """
        Retrieve a specific instance or a set of instances using indexing.

        Args:
            index (int, slice, or np.ndarray): The index, slice, or boolean array to select
                                               the desired instances.

        Returns:
            Instances: A new Instances object containing the selected bounding boxes,
                       segments, and keypoints if present.

        Note:
            When using boolean indexing, make sure to provide a boolean array with the same
            length as the number of instances.
        """
        ...
    
    def flipud(self, h): # -> None:
        """Flips the coordinates of bounding boxes, segments, and keypoints vertically."""
        ...
    
    def fliplr(self, w): # -> None:
        """Reverses the order of the bounding boxes and segments horizontally."""
        ...
    
    def clip(self, w, h): # -> None:
        """Clips bounding boxes, segments, and keypoints values to stay within image boundaries."""
        ...
    
    def remove_zero_area_boxes(self): # -> Tensor | NDArray[bool_]:
        """Remove zero-area boxes, i.e. after clipping some boxes may have zero width or height."""
        ...
    
    def update(self, bboxes, segments=..., keypoints=...): # -> None:
        """Updates instance variables."""
        ...
    
    def __len__(self): # -> int:
        """Return the length of the instance list."""
        ...
    
    @classmethod
    def concatenate(cls, instances_list: List[Instances], axis=...) -> Instances:
        """
        Concatenates a list of Instances objects into a single Instances object.

        Args:
            instances_list (List[Instances]): A list of Instances objects to concatenate.
            axis (int, optional): The axis along which the arrays will be concatenated. Defaults to 0.

        Returns:
            Instances: A new Instances object containing the concatenated bounding boxes,
                       segments, and keypoints if present.

        Note:
            The `Instances` objects in the list should have the same properties, such as
            the format of the bounding boxes, whether keypoints are present, and if the
            coordinates are normalized.
        """
        ...
    
    @property
    def bboxes(self): # -> Tensor | NDArray[Any] | NDArray[floating[_32Bit]]:
        """Return bounding boxes."""
        ...
    



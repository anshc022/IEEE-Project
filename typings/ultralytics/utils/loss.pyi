"""
This type stub file was generated by pyright.
"""

import torch
import torch.nn as nn

class VarifocalLoss(nn.Module):
    """
    Varifocal loss by Zhang et al.

    https://arxiv.org/abs/2008.13367.
    """
    def __init__(self) -> None:
        """Initialize the VarifocalLoss class."""
        ...
    
    @staticmethod
    def forward(pred_score, gt_score, label, alpha=..., gamma=...):
        """Computes varfocal loss."""
        ...
    


class FocalLoss(nn.Module):
    """Wraps focal loss around existing loss_fcn(), i.e. criteria = FocalLoss(nn.BCEWithLogitsLoss(), gamma=1.5)."""
    def __init__(self) -> None:
        """Initializer for FocalLoss class with no parameters."""
        ...
    
    @staticmethod
    def forward(pred, label, gamma=..., alpha=...):
        """Calculates and updates confusion matrix for object detection/classification tasks."""
        ...
    


class DFLoss(nn.Module):
    """Criterion class for computing DFL losses during training."""
    def __init__(self, reg_max=...) -> None:
        """Initialize the DFL module."""
        ...
    
    def __call__(self, pred_dist, target):
        """
        Return sum of left and right DFL losses.

        Distribution Focal Loss (DFL) proposed in Generalized Focal Loss
        https://ieeexplore.ieee.org/document/9792391
        """
        ...
    


class BboxLoss(nn.Module):
    """Criterion class for computing training losses during training."""
    def __init__(self, reg_max=...) -> None:
        """Initialize the BboxLoss module with regularization maximum and DFL settings."""
        ...
    
    def forward(self, pred_dist, pred_bboxes, anchor_points, target_bboxes, target_scores, target_scores_sum, fg_mask): # -> tuple[Any, Any | Tensor]:
        """IoU loss."""
        ...
    


class RotatedBboxLoss(BboxLoss):
    """Criterion class for computing training losses during training."""
    def __init__(self, reg_max) -> None:
        """Initialize the BboxLoss module with regularization maximum and DFL settings."""
        ...
    
    def forward(self, pred_dist, pred_bboxes, anchor_points, target_bboxes, target_scores, target_scores_sum, fg_mask): # -> tuple[Any, Any | Tensor]:
        """IoU loss."""
        ...
    


class KeypointLoss(nn.Module):
    """Criterion class for computing training losses."""
    def __init__(self, sigmas) -> None:
        """Initialize the KeypointLoss class."""
        ...
    
    def forward(self, pred_kpts, gt_kpts, kpt_mask, area):
        """Calculates keypoint loss factor and Euclidean distance loss for predicted and actual keypoints."""
        ...
    


class v8DetectionLoss:
    """Criterion class for computing training losses."""
    def __init__(self, model, tal_topk=...) -> None:
        """Initializes v8DetectionLoss with the model, defining model-related properties and BCE loss function."""
        ...
    
    def preprocess(self, targets, batch_size, scale_tensor): # -> Tensor:
        """Preprocesses the target counts and matches with the input batch size to output a tensor."""
        ...
    
    def bbox_decode(self, anchor_points, pred_dist): # -> Tensor:
        """Decode predicted object bounding box coordinates from anchor points and distribution."""
        ...
    
    def __call__(self, preds, batch): # -> tuple[Tensor | Any, Tensor]:
        """Calculate the sum of the loss for box, cls and dfl multiplied by batch size."""
        ...
    


class v8SegmentationLoss(v8DetectionLoss):
    """Criterion class for computing training losses."""
    def __init__(self, model) -> None:
        """Initializes the v8SegmentationLoss class, taking a de-paralleled model as argument."""
        ...
    
    def __call__(self, preds, batch): # -> tuple[Any, Tensor]:
        """Calculate and return the loss for the YOLO model."""
        ...
    
    @staticmethod
    def single_mask_loss(gt_mask: torch.Tensor, pred: torch.Tensor, proto: torch.Tensor, xyxy: torch.Tensor, area: torch.Tensor) -> torch.Tensor:
        """
        Compute the instance segmentation loss for a single image.

        Args:
            gt_mask (torch.Tensor): Ground truth mask of shape (n, H, W), where n is the number of objects.
            pred (torch.Tensor): Predicted mask coefficients of shape (n, 32).
            proto (torch.Tensor): Prototype masks of shape (32, H, W).
            xyxy (torch.Tensor): Ground truth bounding boxes in xyxy format, normalized to [0, 1], of shape (n, 4).
            area (torch.Tensor): Area of each ground truth bounding box of shape (n,).

        Returns:
            (torch.Tensor): The calculated mask loss for a single image.

        Notes:
            The function uses the equation pred_mask = torch.einsum('in,nhw->ihw', pred, proto) to produce the
            predicted masks from the prototype masks and predicted mask coefficients.
        """
        ...
    
    def calculate_segmentation_loss(self, fg_mask: torch.Tensor, masks: torch.Tensor, target_gt_idx: torch.Tensor, target_bboxes: torch.Tensor, batch_idx: torch.Tensor, proto: torch.Tensor, pred_masks: torch.Tensor, imgsz: torch.Tensor, overlap: bool) -> torch.Tensor:
        """
        Calculate the loss for instance segmentation.

        Args:
            fg_mask (torch.Tensor): A binary tensor of shape (BS, N_anchors) indicating which anchors are positive.
            masks (torch.Tensor): Ground truth masks of shape (BS, H, W) if `overlap` is False, otherwise (BS, ?, H, W).
            target_gt_idx (torch.Tensor): Indexes of ground truth objects for each anchor of shape (BS, N_anchors).
            target_bboxes (torch.Tensor): Ground truth bounding boxes for each anchor of shape (BS, N_anchors, 4).
            batch_idx (torch.Tensor): Batch indices of shape (N_labels_in_batch, 1).
            proto (torch.Tensor): Prototype masks of shape (BS, 32, H, W).
            pred_masks (torch.Tensor): Predicted masks for each anchor of shape (BS, N_anchors, 32).
            imgsz (torch.Tensor): Size of the input image as a tensor of shape (2), i.e., (H, W).
            overlap (bool): Whether the masks in `masks` tensor overlap.

        Returns:
            (torch.Tensor): The calculated loss for instance segmentation.

        Notes:
            The batch loss can be computed for improved speed at higher memory usage.
            For example, pred_mask can be computed as follows:
                pred_mask = torch.einsum('in,nhw->ihw', pred, proto)  # (i, 32) @ (32, 160, 160) -> (i, 160, 160)
        """
        ...
    


class v8PoseLoss(v8DetectionLoss):
    """Criterion class for computing training losses."""
    def __init__(self, model) -> None:
        """Initializes v8PoseLoss with model, sets keypoint variables and declares a keypoint loss instance."""
        ...
    
    def __call__(self, preds, batch): # -> tuple[Tensor | Any, Tensor]:
        """Calculate the total loss and detach it."""
        ...
    
    @staticmethod
    def kpts_decode(anchor_points, pred_kpts):
        """Decodes predicted keypoints to image coordinates."""
        ...
    
    def calculate_keypoints_loss(self, masks, target_gt_idx, keypoints, batch_idx, stride_tensor, target_bboxes, pred_kpts): # -> tuple[Any | Literal[0], Any | Literal[0]]:
        """
        Calculate the keypoints loss for the model.

        This function calculates the keypoints loss and keypoints object loss for a given batch. The keypoints loss is
        based on the difference between the predicted keypoints and ground truth keypoints. The keypoints object loss is
        a binary classification loss that classifies whether a keypoint is present or not.

        Args:
            masks (torch.Tensor): Binary mask tensor indicating object presence, shape (BS, N_anchors).
            target_gt_idx (torch.Tensor): Index tensor mapping anchors to ground truth objects, shape (BS, N_anchors).
            keypoints (torch.Tensor): Ground truth keypoints, shape (N_kpts_in_batch, N_kpts_per_object, kpts_dim).
            batch_idx (torch.Tensor): Batch index tensor for keypoints, shape (N_kpts_in_batch, 1).
            stride_tensor (torch.Tensor): Stride tensor for anchors, shape (N_anchors, 1).
            target_bboxes (torch.Tensor): Ground truth boxes in (x1, y1, x2, y2) format, shape (BS, N_anchors, 4).
            pred_kpts (torch.Tensor): Predicted keypoints, shape (BS, N_anchors, N_kpts_per_object, kpts_dim).

        Returns:
            kpts_loss (torch.Tensor): The keypoints loss.
            kpts_obj_loss (torch.Tensor): The keypoints object loss.
        """
        ...
    


class v8ClassificationLoss:
    """Criterion class for computing training losses."""
    def __call__(self, preds, batch): # -> tuple[Tensor, Tensor]:
        """Compute the classification loss between predictions and true labels."""
        ...
    


class v8OBBLoss(v8DetectionLoss):
    """Calculates losses for object detection, classification, and box distribution in rotated YOLO models."""
    def __init__(self, model) -> None:
        """Initializes v8OBBLoss with model, assigner, and rotated bbox loss; note model must be de-paralleled."""
        ...
    
    def preprocess(self, targets, batch_size, scale_tensor): # -> Tensor:
        """Preprocesses the target counts and matches with the input batch size to output a tensor."""
        ...
    
    def __call__(self, preds, batch): # -> tuple[Any, Tensor]:
        """Calculate and return the loss for the YOLO model."""
        ...
    
    def bbox_decode(self, anchor_points, pred_dist, pred_angle): # -> Tensor:
        """
        Decode predicted object bounding box coordinates from anchor points and distribution.

        Args:
            anchor_points (torch.Tensor): Anchor points, (h*w, 2).
            pred_dist (torch.Tensor): Predicted rotated distance, (bs, h*w, 4).
            pred_angle (torch.Tensor): Predicted angle, (bs, h*w, 1).

        Returns:
            (torch.Tensor): Predicted rotated bounding boxes with angles, (bs, h*w, 5).
        """
        ...
    


class E2EDetectLoss:
    """Criterion class for computing training losses."""
    def __init__(self, model) -> None:
        """Initialize E2EDetectLoss with one-to-many and one-to-one detection losses using the provided model."""
        ...
    
    def __call__(self, preds, batch): # -> tuple[Tensor | Any, Tensor]:
        """Calculate the sum of the loss for box, cls and dfl multiplied by batch size."""
        ...
    



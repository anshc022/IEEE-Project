"""
This type stub file was generated by pyright.
"""

import numpy as np
from ultralytics.utils import SimpleClass, TryExcept, plt_settings

"""Model validation metrics."""
OKS_SIGMA = (np.array([0.26, 0.25, 0.25, 0.35, 0.35, 0.79, 0.79, 0.72, 0.72, 0.62, 0.62, 1.07, 1.07, 0.87, 0.87, 0.89, 0.89]) / 10)
def bbox_ioa(box1, box2, iou=..., eps=...):
    """
    Calculate the intersection over box2 area given box1 and box2. Boxes are in x1y1x2y2 format.

    Args:
        box1 (np.ndarray): A numpy array of shape (n, 4) representing n bounding boxes.
        box2 (np.ndarray): A numpy array of shape (m, 4) representing m bounding boxes.
        iou (bool): Calculate the standard IoU if True else return inter_area/box2_area.
        eps (float, optional): A small value to avoid division by zero. Defaults to 1e-7.

    Returns:
        (np.ndarray): A numpy array of shape (n, m) representing the intersection over box2 area.
    """
    ...

def box_iou(box1, box2, eps=...):
    """
    Calculate intersection-over-union (IoU) of boxes. Both sets of boxes are expected to be in (x1, y1, x2, y2) format.
    Based on https://github.com/pytorch/vision/blob/master/torchvision/ops/boxes.py.

    Args:
        box1 (torch.Tensor): A tensor of shape (N, 4) representing N bounding boxes.
        box2 (torch.Tensor): A tensor of shape (M, 4) representing M bounding boxes.
        eps (float, optional): A small value to avoid division by zero. Defaults to 1e-7.

    Returns:
        (torch.Tensor): An NxM tensor containing the pairwise IoU values for every element in box1 and box2.
    """
    ...

def bbox_iou(box1, box2, xywh=..., GIoU=..., DIoU=..., CIoU=..., eps=...):
    """
    Calculates the Intersection over Union (IoU) between bounding boxes.

    This function supports various shapes for `box1` and `box2` as long as the last dimension is 4.
    For instance, you may pass tensors shaped like (4,), (N, 4), (B, N, 4), or (B, N, 1, 4).
    Internally, the code will split the last dimension into (x, y, w, h) if `xywh=True`,
    or (x1, y1, x2, y2) if `xywh=False`.

    Args:
        box1 (torch.Tensor): A tensor representing one or more bounding boxes, with the last dimension being 4.
        box2 (torch.Tensor): A tensor representing one or more bounding boxes, with the last dimension being 4.
        xywh (bool, optional): If True, input boxes are in (x, y, w, h) format. If False, input boxes are in
                               (x1, y1, x2, y2) format. Defaults to True.
        GIoU (bool, optional): If True, calculate Generalized IoU. Defaults to False.
        DIoU (bool, optional): If True, calculate Distance IoU. Defaults to False.
        CIoU (bool, optional): If True, calculate Complete IoU. Defaults to False.
        eps (float, optional): A small value to avoid division by zero. Defaults to 1e-7.

    Returns:
        (torch.Tensor): IoU, GIoU, DIoU, or CIoU values depending on the specified flags.
    """
    ...

def mask_iou(mask1, mask2, eps=...):
    """
    Calculate masks IoU.

    Args:
        mask1 (torch.Tensor): A tensor of shape (N, n) where N is the number of ground truth objects and n is the
                        product of image width and height.
        mask2 (torch.Tensor): A tensor of shape (M, n) where M is the number of predicted objects and n is the
                        product of image width and height.
        eps (float, optional): A small value to avoid division by zero. Defaults to 1e-7.

    Returns:
        (torch.Tensor): A tensor of shape (N, M) representing masks IoU.
    """
    ...

def kpt_iou(kpt1, kpt2, area, sigma, eps=...):
    """
    Calculate Object Keypoint Similarity (OKS).

    Args:
        kpt1 (torch.Tensor): A tensor of shape (N, 17, 3) representing ground truth keypoints.
        kpt2 (torch.Tensor): A tensor of shape (M, 17, 3) representing predicted keypoints.
        area (torch.Tensor): A tensor of shape (N,) representing areas from ground truth.
        sigma (list): A list containing 17 values representing keypoint scales.
        eps (float, optional): A small value to avoid division by zero. Defaults to 1e-7.

    Returns:
        (torch.Tensor): A tensor of shape (N, M) representing keypoint similarities.
    """
    ...

def probiou(obb1, obb2, CIoU=..., eps=...):
    """
    Calculate probabilistic IoU between oriented bounding boxes.

    Implements the algorithm from https://arxiv.org/pdf/2106.06072v1.pdf.

    Args:
        obb1 (torch.Tensor): Ground truth OBBs, shape (N, 5), format xywhr.
        obb2 (torch.Tensor): Predicted OBBs, shape (N, 5), format xywhr.
        CIoU (bool, optional): If True, calculate CIoU. Defaults to False.
        eps (float, optional): Small value to avoid division by zero. Defaults to 1e-7.

    Returns:
        (torch.Tensor): OBB similarities, shape (N,).

    Note:
        OBB format: [center_x, center_y, width, height, rotation_angle].
        If CIoU is True, returns CIoU instead of IoU.
    """
    ...

def batch_probiou(obb1, obb2, eps=...): # -> Tensor | Any:
    """
    Calculate the prob IoU between oriented bounding boxes, https://arxiv.org/pdf/2106.06072v1.pdf.

    Args:
        obb1 (torch.Tensor | np.ndarray): A tensor of shape (N, 5) representing ground truth obbs, with xywhr format.
        obb2 (torch.Tensor | np.ndarray): A tensor of shape (M, 5) representing predicted obbs, with xywhr format.
        eps (float, optional): A small value to avoid division by zero. Defaults to 1e-7.

    Returns:
        (torch.Tensor): A tensor of shape (N, M) representing obb similarities.
    """
    ...

def smooth_bce(eps=...): # -> tuple[float, float]:
    """
    Computes smoothed positive and negative Binary Cross-Entropy targets.

    This function calculates positive and negative label smoothing BCE targets based on a given epsilon value.
    For implementation details, refer to https://github.com/ultralytics/yolov3/issues/238#issuecomment-598028441.

    Args:
        eps (float, optional): The epsilon value for label smoothing. Defaults to 0.1.

    Returns:
        (tuple): A tuple containing the positive and negative label smoothing BCE targets.
    """
    ...

class ConfusionMatrix:
    """
    A class for calculating and updating a confusion matrix for object detection and classification tasks.

    Attributes:
        task (str): The type of task, either 'detect' or 'classify'.
        matrix (np.ndarray): The confusion matrix, with dimensions depending on the task.
        nc (int): The number of classes.
        conf (float): The confidence threshold for detections.
        iou_thres (float): The Intersection over Union threshold.
    """
    def __init__(self, nc, conf=..., iou_thres=..., task=...) -> None:
        """Initialize attributes for the YOLO model."""
        ...
    
    def process_cls_preds(self, preds, targets): # -> None:
        """
        Update confusion matrix for classification task.

        Args:
            preds (Array[N, min(nc,5)]): Predicted class labels.
            targets (Array[N, 1]): Ground truth class labels.
        """
        ...
    
    def process_batch(self, detections, gt_bboxes, gt_cls): # -> None:
        """
        Update confusion matrix for object detection task.

        Args:
            detections (Array[N, 6] | Array[N, 7]): Detected bounding boxes and their associated information.
                                      Each row should contain (x1, y1, x2, y2, conf, class)
                                      or with an additional element `angle` when it's obb.
            gt_bboxes (Array[M, 4]| Array[N, 5]): Ground truth bounding boxes with xyxy/xyxyr format.
            gt_cls (Array[M]): The class labels.
        """
        ...
    
    def matrix(self): # -> Callable[[], ...]:
        """Returns the confusion matrix."""
        ...
    
    def tp_fp(self): # -> tuple[Any, Any]:
        """Returns true positives and false positives."""
        ...
    
    @TryExcept("WARNING ⚠️ ConfusionMatrix plot failure")
    @plt_settings()
    def plot(self, normalize=..., save_dir=..., names=..., on_plot=...): # -> None:
        """
        Plot the confusion matrix using seaborn and save it to a file.

        Args:
            normalize (bool): Whether to normalize the confusion matrix.
            save_dir (str): Directory where the plot will be saved.
            names (tuple): Names of classes, used as labels on the plot.
            on_plot (func): An optional callback to pass plots path and data when they are rendered.
        """
        ...
    
    def print(self): # -> None:
        """Print the confusion matrix to the console."""
        ...
    


def smooth(y, f=...): # -> NDArray[floating[Any]]:
    """Box filter of fraction f."""
    ...

@plt_settings()
def plot_pr_curve(px, py, ap, save_dir=..., names=..., on_plot=...): # -> None:
    """Plots a precision-recall curve."""
    ...

@plt_settings()
def plot_mc_curve(px, py, save_dir=..., names=..., xlabel=..., ylabel=..., on_plot=...): # -> None:
    """Plots a metric-confidence curve."""
    ...

def compute_ap(recall, precision): # -> tuple[Any | bool_, NDArray[Any], NDArray[Any]]:
    """
    Compute the average precision (AP) given the recall and precision curves.

    Args:
        recall (list): The recall curve.
        precision (list): The precision curve.

    Returns:
        (float): Average precision.
        (np.ndarray): Precision envelope curve.
        (np.ndarray): Modified recall curve with sentinel values added at the beginning and end.
    """
    ...

def ap_per_class(tp, conf, pred_cls, target_cls, plot=..., on_plot=..., save_dir=..., names=..., eps=..., prefix=...): # -> tuple[Any, Any, ndarray[Any, dtype[float64]], ndarray[Any, dtype[float64]], ndarray[Any, dtype[floating[Any]]], NDArray[float64], Any, NDArray[float64], NDArray[float64], NDArray[floating[Any]], NDArray[floating[Any]], NDArray[Any]]:
    """
    Computes the average precision per class for object detection evaluation.

    Args:
        tp (np.ndarray): Binary array indicating whether the detection is correct (True) or not (False).
        conf (np.ndarray): Array of confidence scores of the detections.
        pred_cls (np.ndarray): Array of predicted classes of the detections.
        target_cls (np.ndarray): Array of true classes of the detections.
        plot (bool, optional): Whether to plot PR curves or not. Defaults to False.
        on_plot (func, optional): A callback to pass plots path and data when they are rendered. Defaults to None.
        save_dir (Path, optional): Directory to save the PR curves. Defaults to an empty path.
        names (dict, optional): Dict of class names to plot PR curves. Defaults to an empty tuple.
        eps (float, optional): A small value to avoid division by zero. Defaults to 1e-16.
        prefix (str, optional): A prefix string for saving the plot files. Defaults to an empty string.

    Returns:
        tp (np.ndarray): True positive counts at threshold given by max F1 metric for each class.Shape: (nc,).
        fp (np.ndarray): False positive counts at threshold given by max F1 metric for each class. Shape: (nc,).
        p (np.ndarray): Precision values at threshold given by max F1 metric for each class. Shape: (nc,).
        r (np.ndarray): Recall values at threshold given by max F1 metric for each class. Shape: (nc,).
        f1 (np.ndarray): F1-score values at threshold given by max F1 metric for each class. Shape: (nc,).
        ap (np.ndarray): Average precision for each class at different IoU thresholds. Shape: (nc, 10).
        unique_classes (np.ndarray): An array of unique classes that have data. Shape: (nc,).
        p_curve (np.ndarray): Precision curves for each class. Shape: (nc, 1000).
        r_curve (np.ndarray): Recall curves for each class. Shape: (nc, 1000).
        f1_curve (np.ndarray): F1-score curves for each class. Shape: (nc, 1000).
        x (np.ndarray): X-axis values for the curves. Shape: (1000,).
        prec_values (np.ndarray): Precision values at mAP@0.5 for each class. Shape: (nc, 1000).
    """
    ...

class Metric(SimpleClass):
    """
    Class for computing evaluation metrics for YOLOv8 model.

    Attributes:
        p (list): Precision for each class. Shape: (nc,).
        r (list): Recall for each class. Shape: (nc,).
        f1 (list): F1 score for each class. Shape: (nc,).
        all_ap (list): AP scores for all classes and all IoU thresholds. Shape: (nc, 10).
        ap_class_index (list): Index of class for each AP score. Shape: (nc,).
        nc (int): Number of classes.

    Methods:
        ap50(): AP at IoU threshold of 0.5 for all classes. Returns: List of AP scores. Shape: (nc,) or [].
        ap(): AP at IoU thresholds from 0.5 to 0.95 for all classes. Returns: List of AP scores. Shape: (nc,) or [].
        mp(): Mean precision of all classes. Returns: Float.
        mr(): Mean recall of all classes. Returns: Float.
        map50(): Mean AP at IoU threshold of 0.5 for all classes. Returns: Float.
        map75(): Mean AP at IoU threshold of 0.75 for all classes. Returns: Float.
        map(): Mean AP at IoU thresholds from 0.5 to 0.95 for all classes. Returns: Float.
        mean_results(): Mean of results, returns mp, mr, map50, map.
        class_result(i): Class-aware result, returns p[i], r[i], ap50[i], ap[i].
        maps(): mAP of each class. Returns: Array of mAP scores, shape: (nc,).
        fitness(): Model fitness as a weighted combination of metrics. Returns: Float.
        update(results): Update metric attributes with new evaluation results.
    """
    def __init__(self) -> None:
        """Initializes a Metric instance for computing evaluation metrics for the YOLOv8 model."""
        ...
    
    @property
    def ap50(self): # -> list[Any]:
        """
        Returns the Average Precision (AP) at an IoU threshold of 0.5 for all classes.

        Returns:
            (np.ndarray, list): Array of shape (nc,) with AP50 values per class, or an empty list if not available.
        """
        ...
    
    @property
    def ap(self): # -> list[Any]:
        """
        Returns the Average Precision (AP) at an IoU threshold of 0.5-0.95 for all classes.

        Returns:
            (np.ndarray, list): Array of shape (nc,) with AP50-95 values per class, or an empty list if not available.
        """
        ...
    
    @property
    def mp(self): # -> float:
        """
        Returns the Mean Precision of all classes.

        Returns:
            (float): The mean precision of all classes.
        """
        ...
    
    @property
    def mr(self): # -> float:
        """
        Returns the Mean Recall of all classes.

        Returns:
            (float): The mean recall of all classes.
        """
        ...
    
    @property
    def map50(self): # -> float:
        """
        Returns the mean Average Precision (mAP) at an IoU threshold of 0.5.

        Returns:
            (float): The mAP at an IoU threshold of 0.5.
        """
        ...
    
    @property
    def map75(self): # -> float:
        """
        Returns the mean Average Precision (mAP) at an IoU threshold of 0.75.

        Returns:
            (float): The mAP at an IoU threshold of 0.75.
        """
        ...
    
    @property
    def map(self): # -> float:
        """
        Returns the mean Average Precision (mAP) over IoU thresholds of 0.5 - 0.95 in steps of 0.05.

        Returns:
            (float): The mAP over IoU thresholds of 0.5 - 0.95 in steps of 0.05.
        """
        ...
    
    def mean_results(self): # -> list[Any | float]:
        """Mean of results, return mp, mr, map50, map."""
        ...
    
    def class_result(self, i): # -> tuple[Any, Any, Any, Any]:
        """Class-aware result, return p[i], r[i], ap50[i], ap[i]."""
        ...
    
    @property
    def maps(self): # -> NDArray[floating[Any]]:
        """MAP of each class."""
        ...
    
    def fitness(self): # -> Any:
        """Model fitness as a weighted combination of metrics."""
        ...
    
    def update(self, results): # -> None:
        """
        Updates the evaluation metrics of the model with a new set of results.

        Args:
            results (tuple): A tuple containing the following evaluation metrics:
                - p (list): Precision for each class. Shape: (nc,).
                - r (list): Recall for each class. Shape: (nc,).
                - f1 (list): F1 score for each class. Shape: (nc,).
                - all_ap (list): AP scores for all classes and all IoU thresholds. Shape: (nc, 10).
                - ap_class_index (list): Index of class for each AP score. Shape: (nc,).

        Side Effects:
            Updates the class attributes `self.p`, `self.r`, `self.f1`, `self.all_ap`, and `self.ap_class_index` based
            on the values provided in the `results` tuple.
        """
        ...
    
    @property
    def curves(self): # -> list[Any]:
        """Returns a list of curves for accessing specific metrics curves."""
        ...
    
    @property
    def curves_results(self): # -> list[list[Any]]:
        """Returns a list of curves for accessing specific metrics curves."""
        ...
    


class DetMetrics(SimpleClass):
    """
    Utility class for computing detection metrics such as precision, recall, and mean average precision (mAP) of an
    object detection model.

    Args:
        save_dir (Path): A path to the directory where the output plots will be saved. Defaults to current directory.
        plot (bool): A flag that indicates whether to plot precision-recall curves for each class. Defaults to False.
        on_plot (func): An optional callback to pass plots path and data when they are rendered. Defaults to None.
        names (dict of str): A dict of strings that represents the names of the classes. Defaults to an empty tuple.

    Attributes:
        save_dir (Path): A path to the directory where the output plots will be saved.
        plot (bool): A flag that indicates whether to plot the precision-recall curves for each class.
        on_plot (func): An optional callback to pass plots path and data when they are rendered.
        names (dict of str): A dict of strings that represents the names of the classes.
        box (Metric): An instance of the Metric class for storing the results of the detection metrics.
        speed (dict): A dictionary for storing the execution time of different parts of the detection process.

    Methods:
        process(tp, conf, pred_cls, target_cls): Updates the metric results with the latest batch of predictions.
        keys: Returns a list of keys for accessing the computed detection metrics.
        mean_results: Returns a list of mean values for the computed detection metrics.
        class_result(i): Returns a list of values for the computed detection metrics for a specific class.
        maps: Returns a dictionary of mean average precision (mAP) values for different IoU thresholds.
        fitness: Computes the fitness score based on the computed detection metrics.
        ap_class_index: Returns a list of class indices sorted by their average precision (AP) values.
        results_dict: Returns a dictionary that maps detection metric keys to their computed values.
        curves: TODO
        curves_results: TODO
    """
    def __init__(self, save_dir=..., plot=..., on_plot=..., names=...) -> None:
        """Initialize a DetMetrics instance with a save directory, plot flag, callback function, and class names."""
        ...
    
    def process(self, tp, conf, pred_cls, target_cls): # -> None:
        """Process predicted results for object detection and update metrics."""
        ...
    
    @property
    def keys(self): # -> list[str]:
        """Returns a list of keys for accessing specific metrics."""
        ...
    
    def mean_results(self): # -> list[Any | float]:
        """Calculate mean of detected objects & return precision, recall, mAP50, and mAP50-95."""
        ...
    
    def class_result(self, i): # -> tuple[Any, Any, Any, Any]:
        """Return the result of evaluating the performance of an object detection model on a specific class."""
        ...
    
    @property
    def maps(self): # -> NDArray[floating[Any]]:
        """Returns mean Average Precision (mAP) scores per class."""
        ...
    
    @property
    def fitness(self): # -> Any:
        """Returns the fitness of box object."""
        ...
    
    @property
    def ap_class_index(self): # -> list[Any]:
        """Returns the average precision index per class."""
        ...
    
    @property
    def results_dict(self): # -> dict[str, Any | float]:
        """Returns dictionary of computed performance metrics and statistics."""
        ...
    
    @property
    def curves(self): # -> list[str]:
        """Returns a list of curves for accessing specific metrics curves."""
        ...
    
    @property
    def curves_results(self): # -> list[list[Any]]:
        """Returns dictionary of computed performance metrics and statistics."""
        ...
    


class SegmentMetrics(SimpleClass):
    """
    Calculates and aggregates detection and segmentation metrics over a given set of classes.

    Args:
        save_dir (Path): Path to the directory where the output plots should be saved. Default is the current directory.
        plot (bool): Whether to save the detection and segmentation plots. Default is False.
        on_plot (func): An optional callback to pass plots path and data when they are rendered. Defaults to None.
        names (list): List of class names. Default is an empty list.

    Attributes:
        save_dir (Path): Path to the directory where the output plots should be saved.
        plot (bool): Whether to save the detection and segmentation plots.
        on_plot (func): An optional callback to pass plots path and data when they are rendered.
        names (list): List of class names.
        box (Metric): An instance of the Metric class to calculate box detection metrics.
        seg (Metric): An instance of the Metric class to calculate mask segmentation metrics.
        speed (dict): Dictionary to store the time taken in different phases of inference.

    Methods:
        process(tp_m, tp_b, conf, pred_cls, target_cls): Processes metrics over the given set of predictions.
        mean_results(): Returns the mean of the detection and segmentation metrics over all the classes.
        class_result(i): Returns the detection and segmentation metrics of class `i`.
        maps: Returns the mean Average Precision (mAP) scores for IoU thresholds ranging from 0.50 to 0.95.
        fitness: Returns the fitness scores, which are a single weighted combination of metrics.
        ap_class_index: Returns the list of indices of classes used to compute Average Precision (AP).
        results_dict: Returns the dictionary containing all the detection and segmentation metrics and fitness score.
    """
    def __init__(self, save_dir=..., plot=..., on_plot=..., names=...) -> None:
        """Initialize a SegmentMetrics instance with a save directory, plot flag, callback function, and class names."""
        ...
    
    def process(self, tp, tp_m, conf, pred_cls, target_cls): # -> None:
        """
        Processes the detection and segmentation metrics over the given set of predictions.

        Args:
            tp (list): List of True Positive boxes.
            tp_m (list): List of True Positive masks.
            conf (list): List of confidence scores.
            pred_cls (list): List of predicted classes.
            target_cls (list): List of target classes.
        """
        ...
    
    @property
    def keys(self): # -> list[str]:
        """Returns a list of keys for accessing metrics."""
        ...
    
    def mean_results(self): # -> list[Any | float]:
        """Return the mean metrics for bounding box and segmentation results."""
        ...
    
    def class_result(self, i): # -> tuple[Any, Any, Any, Any, Any, Any, Any, Any]:
        """Returns classification results for a specified class index."""
        ...
    
    @property
    def maps(self): # -> NDArray[floating[Any]]:
        """Returns mAP scores for object detection and semantic segmentation models."""
        ...
    
    @property
    def fitness(self): # -> Any:
        """Get the fitness score for both segmentation and bounding box models."""
        ...
    
    @property
    def ap_class_index(self): # -> list[Any]:
        """Boxes and masks have the same ap_class_index."""
        ...
    
    @property
    def results_dict(self): # -> dict[str, Any | float]:
        """Returns results of object detection model for evaluation."""
        ...
    
    @property
    def curves(self): # -> list[str]:
        """Returns a list of curves for accessing specific metrics curves."""
        ...
    
    @property
    def curves_results(self): # -> list[list[Any]]:
        """Returns dictionary of computed performance metrics and statistics."""
        ...
    


class PoseMetrics(SegmentMetrics):
    """
    Calculates and aggregates detection and pose metrics over a given set of classes.

    Args:
        save_dir (Path): Path to the directory where the output plots should be saved. Default is the current directory.
        plot (bool): Whether to save the detection and segmentation plots. Default is False.
        on_plot (func): An optional callback to pass plots path and data when they are rendered. Defaults to None.
        names (list): List of class names. Default is an empty list.

    Attributes:
        save_dir (Path): Path to the directory where the output plots should be saved.
        plot (bool): Whether to save the detection and segmentation plots.
        on_plot (func): An optional callback to pass plots path and data when they are rendered.
        names (list): List of class names.
        box (Metric): An instance of the Metric class to calculate box detection metrics.
        pose (Metric): An instance of the Metric class to calculate mask segmentation metrics.
        speed (dict): Dictionary to store the time taken in different phases of inference.

    Methods:
        process(tp_m, tp_b, conf, pred_cls, target_cls): Processes metrics over the given set of predictions.
        mean_results(): Returns the mean of the detection and segmentation metrics over all the classes.
        class_result(i): Returns the detection and segmentation metrics of class `i`.
        maps: Returns the mean Average Precision (mAP) scores for IoU thresholds ranging from 0.50 to 0.95.
        fitness: Returns the fitness scores, which are a single weighted combination of metrics.
        ap_class_index: Returns the list of indices of classes used to compute Average Precision (AP).
        results_dict: Returns the dictionary containing all the detection and segmentation metrics and fitness score.
    """
    def __init__(self, save_dir=..., plot=..., on_plot=..., names=...) -> None:
        """Initialize the PoseMetrics class with directory path, class names, and plotting options."""
        ...
    
    def process(self, tp, tp_p, conf, pred_cls, target_cls): # -> None:
        """
        Processes the detection and pose metrics over the given set of predictions.

        Args:
            tp (list): List of True Positive boxes.
            tp_p (list): List of True Positive keypoints.
            conf (list): List of confidence scores.
            pred_cls (list): List of predicted classes.
            target_cls (list): List of target classes.
        """
        ...
    
    @property
    def keys(self): # -> list[str]:
        """Returns list of evaluation metric keys."""
        ...
    
    def mean_results(self): # -> list[Any | float]:
        """Return the mean results of box and pose."""
        ...
    
    def class_result(self, i): # -> tuple[Any, Any, Any, Any, Any, Any, Any, Any]:
        """Return the class-wise detection results for a specific class i."""
        ...
    
    @property
    def maps(self): # -> NDArray[floating[Any]]:
        """Returns the mean average precision (mAP) per class for both box and pose detections."""
        ...
    
    @property
    def fitness(self): # -> Any:
        """Computes classification metrics and speed using the `targets` and `pred` inputs."""
        ...
    
    @property
    def curves(self): # -> list[str]:
        """Returns a list of curves for accessing specific metrics curves."""
        ...
    
    @property
    def curves_results(self): # -> list[list[Any]]:
        """Returns dictionary of computed performance metrics and statistics."""
        ...
    


class ClassifyMetrics(SimpleClass):
    """
    Class for computing classification metrics including top-1 and top-5 accuracy.

    Attributes:
        top1 (float): The top-1 accuracy.
        top5 (float): The top-5 accuracy.
        speed (Dict[str, float]): A dictionary containing the time taken for each step in the pipeline.
        fitness (float): The fitness of the model, which is equal to top-5 accuracy.
        results_dict (Dict[str, Union[float, str]]): A dictionary containing the classification metrics and fitness.
        keys (List[str]): A list of keys for the results_dict.

    Methods:
        process(targets, pred): Processes the targets and predictions to compute classification metrics.
    """
    def __init__(self) -> None:
        """Initialize a ClassifyMetrics instance."""
        ...
    
    def process(self, targets, pred): # -> None:
        """Target classes and predicted classes."""
        ...
    
    @property
    def fitness(self): # -> float:
        """Returns mean of top-1 and top-5 accuracies as fitness score."""
        ...
    
    @property
    def results_dict(self): # -> dict[str, int | Any | float]:
        """Returns a dictionary with model's performance metrics and fitness score."""
        ...
    
    @property
    def keys(self): # -> list[str]:
        """Returns a list of keys for the results_dict property."""
        ...
    
    @property
    def curves(self): # -> list[Any]:
        """Returns a list of curves for accessing specific metrics curves."""
        ...
    
    @property
    def curves_results(self): # -> list[Any]:
        """Returns a list of curves for accessing specific metrics curves."""
        ...
    


class OBBMetrics(SimpleClass):
    """Metrics for evaluating oriented bounding box (OBB) detection, see https://arxiv.org/pdf/2106.06072.pdf."""
    def __init__(self, save_dir=..., plot=..., on_plot=..., names=...) -> None:
        """Initialize an OBBMetrics instance with directory, plotting, callback, and class names."""
        ...
    
    def process(self, tp, conf, pred_cls, target_cls): # -> None:
        """Process predicted results for object detection and update metrics."""
        ...
    
    @property
    def keys(self): # -> list[str]:
        """Returns a list of keys for accessing specific metrics."""
        ...
    
    def mean_results(self): # -> list[Any | float]:
        """Calculate mean of detected objects & return precision, recall, mAP50, and mAP50-95."""
        ...
    
    def class_result(self, i): # -> tuple[Any, Any, Any, Any]:
        """Return the result of evaluating the performance of an object detection model on a specific class."""
        ...
    
    @property
    def maps(self): # -> NDArray[floating[Any]]:
        """Returns mean Average Precision (mAP) scores per class."""
        ...
    
    @property
    def fitness(self): # -> Any:
        """Returns the fitness of box object."""
        ...
    
    @property
    def ap_class_index(self): # -> list[Any]:
        """Returns the average precision index per class."""
        ...
    
    @property
    def results_dict(self): # -> dict[str, Any | float]:
        """Returns dictionary of computed performance metrics and statistics."""
        ...
    
    @property
    def curves(self): # -> list[Any]:
        """Returns a list of curves for accessing specific metrics curves."""
        ...
    
    @property
    def curves_results(self): # -> list[Any]:
        """Returns a list of curves for accessing specific metrics curves."""
        ...
    


